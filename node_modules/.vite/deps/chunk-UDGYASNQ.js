import {
  is_void
} from "./chunk-QVEVRQ5O.js";
import {
  store_invalid_shape,
  svelte_element_invalid_this_value
} from "./chunk-LPTKCXUS.js";
import {
  get_prototype_of,
  is_array,
  object_prototype
} from "./chunk-XCEQXHQA.js";
import {
  DEV
} from "./chunk-IP2U24VQ.js";

// node_modules/svelte/src/internal/shared/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function dynamic_void_element_content(tag) {
  if (DEV) {
    console.warn(`%c[svelte] dynamic_void_element_content
%c\`<svelte:element this="${tag}">\` is a void element — it cannot have content`, bold, normal);
  } else {
    console.warn("dynamic_void_element_content");
  }
}
function state_snapshot_uncloneable(properties) {
  if (DEV) {
    console.warn(`%c[svelte] state_snapshot_uncloneable
%c${properties ? `The following properties cannot be cloned with \`$state.snapshot\` — the return value contains the originals:

${properties}` : "Value cannot be cloned with `$state.snapshot` — the original value was returned"}`, bold, normal);
  } else {
    console.warn("state_snapshot_uncloneable");
  }
}

// node_modules/svelte/src/internal/shared/clone.js
var empty = [];
function snapshot(value, skip_warning = false) {
  if (DEV && !skip_warning) {
    const paths = [];
    const copy = clone(value, /* @__PURE__ */ new Map(), "", paths);
    if (paths.length === 1 && paths[0] === "") {
      state_snapshot_uncloneable();
    } else if (paths.length > 0) {
      const slice = paths.length > 10 ? paths.slice(0, 7) : paths.slice(0, 10);
      const excess = paths.length - slice.length;
      let uncloned = slice.map((path) => `- <value>${path}`).join("\n");
      if (excess > 0) uncloned += `
- ...and ${excess} more`;
      state_snapshot_uncloneable(uncloned);
    }
    return copy;
  }
  return clone(value, /* @__PURE__ */ new Map(), "", empty);
}
function clone(value, cloned, path, paths) {
  if (typeof value === "object" && value !== null) {
    const unwrapped = cloned.get(value);
    if (unwrapped !== void 0) return unwrapped;
    if (value instanceof Map) return (
      /** @type {Snapshot<T>} */
      new Map(value)
    );
    if (value instanceof Set) return (
      /** @type {Snapshot<T>} */
      new Set(value)
    );
    if (is_array(value)) {
      const copy = (
        /** @type {Snapshot<any>} */
        []
      );
      cloned.set(value, copy);
      for (let i = 0; i < value.length; i += 1) {
        copy.push(clone(value[i], cloned, DEV ? `${path}[${i}]` : path, paths));
      }
      return copy;
    }
    if (get_prototype_of(value) === object_prototype) {
      const copy = {};
      cloned.set(value, copy);
      for (var key in value) {
        copy[key] = clone(value[key], cloned, DEV ? `${path}.${key}` : path, paths);
      }
      return copy;
    }
    if (value instanceof Date) {
      return (
        /** @type {Snapshot<T>} */
        structuredClone(value)
      );
    }
    if (typeof /** @type {T & { toJSON?: any } } */
    value.toJSON === "function") {
      return clone(
        /** @type {T & { toJSON(): any } } */
        value.toJSON(),
        cloned,
        DEV ? `${path}.toJSON()` : path,
        paths
      );
    }
  }
  if (value instanceof EventTarget) {
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
  try {
    return (
      /** @type {Snapshot<T>} */
      structuredClone(value)
    );
  } catch (e) {
    if (DEV) {
      paths.push(path);
    }
    return (
      /** @type {Snapshot<T>} */
      value
    );
  }
}

// node_modules/svelte/src/internal/shared/validate.js
function validate_void_dynamic_element(tag_fn) {
  const tag = tag_fn();
  if (tag && is_void(tag)) {
    dynamic_void_element_content(tag);
  }
}
function validate_dynamic_element_tag(tag_fn) {
  const tag = tag_fn();
  const is_string = typeof tag === "string";
  if (tag && !is_string) {
    svelte_element_invalid_this_value();
  }
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    store_invalid_shape(name);
  }
}

export {
  snapshot,
  validate_void_dynamic_element,
  validate_dynamic_element_tag,
  validate_store
};
//# sourceMappingURL=chunk-UDGYASNQ.js.map
